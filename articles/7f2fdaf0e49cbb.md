---
title: "そこに仮説はあるんか？〜コードを書く前に立てたい「問い」と、クリティカル・シンキングの話〜"
emoji: "🤔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["思考法", "開発手法", "チーム開発"]
published: false
---

## 導入：某CMから始まった問い

某CMの「そこに愛はあるんか？」が、最近頭の中で「仮説」に変換される。

最近の開発を振り返ると、コードを書くことが価値の本質ではないと感じることが増えた。もしかすると本当に必要なのは「なぜこのコードを書くのか？」という問いと、その裏の仮説なのかもしれない。

## 課題：実装が"思考停止"になりがち問題

実務では「仕様をそのまま実装する」場面が多い。気づけば、自分も含めて指示通り動くだけになっていることがある。

その結果、なぜその実装が有効だったのかを学べず、改善もできない状態に陥ってしまうことがあるのではないだろうか。

## 仮説の力：コードを思考に変える

仮説を立てるとは、「どうすれば目的を達成できるか？」の仮の答えを持つこと。

仮説があると：
- 実装が検証可能になる
- 学びが残る
- 次回に活かせる知見が蓄積される

これこそが、クリティカル・シンキングの中核の一つだと思う。

## クリティカル・シンキングとの接続

クリティカル・シンキングとは「目的は何か？前提は正しいか？他に選択肢はあるか？」を問い直すこと。

コードを書く前の仮説立ては、これらをすべて内包している。

つまり、**コードを書くとは、仮説を通じて戦略的な判断を実行すること**なのかもしれない。

## 3つの問い：コードを書く前に自分に問うこと

| 問い | 解説 | 例（軽め） |
| --- | --- | --- |
| ① なぜやる？ | 目的・背景 | KPI改善？CS工数削減？UX向上？ |
| ② どういう狙い？ | 手段の意図 | バリデーション強化で早期離脱防止など |
| ③ 何を仮定した？ | 検証視点 | 「多くの離脱は入力ミスが原因」と仮定、など |

## コード例（仮説なし vs 仮説あり）

### React.js の例：状態管理の選択

**🟥 仮説なしのコード**

他のコンポーネントでuseStateを使っているから、とりあえず同じように書いてしまう。

```javascript
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // 複雑な状態更新ロジックが散らばる...
  const addTodo = (text) => {
    setIsLoading(true);
    // 複雑な処理...
    setTodos(prev => [...prev, newTodo]);
    setIsLoading(false);
  };
}
```

**✅ 仮説ありのコード**

「この画面は状態遷移が複雑になりそうだから、useReducerで一元管理した方が後々メンテしやすいのでは？」という仮説を立てて実装。

```javascript
// 仮説：「Todo操作は複数の状態を同時に更新することが多く、
// useReducerで状態遷移を明示的にした方が予期しないバグを防げる」
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO_START':
      return { ...state, isLoading: true, error: null };
    case 'ADD_TODO_SUCCESS':
      return { 
        ...state, 
        todos: [...state.todos, action.todo],
        isLoading: false 
      };
    // ...
  }
}

function TodoList() {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  // 状態遷移が明確で、テストも書きやすい
}
```

### Rails の例：バリデーションの実装

**🟥 仮説なしのコード**

他のモデルと同じようにpresenceバリデーションを追加しただけ。

```ruby
class User < ApplicationRecord
  validates :email, presence: true
  validates :name, presence: true
end
```

**✅ 仮説ありのコード**

「ユーザー登録時のエラーは、具体的で親切なメッセージにすることで離脱率を下げられるのでは？」という仮説を立てて実装。

```ruby
class User < ApplicationRecord
  # 仮説：「メールアドレスの形式エラーとDB重複エラーを
  # 分けて表示することで、ユーザーが次のアクションを取りやすくなる」
  validates :email, 
    presence: { message: 'メールアドレスを入力してください' },
    format: { 
      with: URI::MailTo::EMAIL_REGEXP, 
      message: 'メールアドレスの形式が正しくありません' 
    },
    uniqueness: { 
      message: 'このメールアドレスは既に登録されています' 
    }
    
  validates :name, 
    presence: { message: 'お名前を入力してください' },
    length: { 
      minimum: 2, 
      message: 'お名前は2文字以上で入力してください' 
    }
end
```

### 違いは何か？

**仮説なしコード**は真似て動かすことが目標だが、**仮説ありコード**は「なぜその選択をしたのか」が明確。

- どうしてそう書くのが良いか → 明確な理由がある
- 他の選択肢は無かったのか → 検討した跡が残る  
- 優先順位は何なのか → トレードオフが見える
- 思考の基準は何か → チームで共有できる判断軸がある

## 現場での実践：仮説をチームで共有するには

- PRテンプレに「仮説」の項目を入れる
- スプリント計画時に「今回の開発で検証したいことは？」を共有する
- 実装が終わったあとも、「仮説通りだったか？」をふりかえる場をつくる

## 結論：仮説があるから学べるし、次がある

コードを書いた成果とは「通った」「動いた」ではなく、「何を学べたか」である。

そしてそれは、仮説を立てないと得られない。

**「そこに仮説はあるんか？」と自分に問うことは、開発者が思考を止めないための最初の一歩**になるのではないだろうか。

## 締め：今日書いたコードに問いを投げてみて

今日書いたコードを、明日読む自分がどう思うか？

「ちゃんと仮説を持って書いてるな」と思えるなら、それはもう戦略的な開発と言えるかもしれない。
