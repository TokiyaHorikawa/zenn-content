---
title: "CursorでAIに小さなユニットでタスクを依頼する"
emoji: "🔖"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["cursor", "ai", "poem"]
published: false
---

## この記事はなに？

この記事では、現時点でのAIツールで確実に恩恵を受けるためには、
**スコープを小さくすることで確実性を上げることが重要である**という考え方を紹介します。

↓↓↓ Project Rulesなどの活用はこちらの記事から ↓↓↓
https://zenn.dev/globis/articles/cursor-project-rules

扱わないもの
ツールの機能説明、チャレンジングなハック的アプローチのAIに自由に編集・参照させている `memories.md` ファイルや大きなタスクの context を自然言語でまとめておく `issues.md` ファイルや`.cursor/rules`をAIに自動で修正してもらうなど

## 前提

- Cursor Composer Agent に **大きなタスクは渡さない**
- AIには、**小さなユニットに分けてタスクを実行してもらう**事で確実性を上げる

複雑性が小さいタスクや、既存コードが小さい場合には、Cursor Composer Agent に大きなタスクを渡してもらっても十分にWorkすると思います。

ただ、複雑性とコード量が増えてくると、小さい単位にタスクを切らないと、結局待ち時間が大きいのにあまり使えないコードが上がってきて終わった。または、テストが通らないまま堂々巡りに陥り25 limitで終了する。みたいになることが多いと感じています。

### 複雑なタスクはAIが思う結果を出さない

なぜか
**人間が正しくAIに context を渡す事ができない**からでは無いか？と考えます。

そこで、人間の context を渡す能力とコストがボトルネックになってしまうなら、一旦スコープを小さくして context を正しく渡せるようにしてみようという発想です。

(Anthropic CEOの語る「事前学習 + 強化学習」のモデルの登場か、Cursor等のアプリケーション側で優秀な memories 機能が備われば話は違うのかもしれませんね)

### 実装のポイント

- **ユニットを小さく**
- **テストを先に書いて、成果物を明確に**

### モデルとインターフェースの選択

- **簡単なタスク:** command + K (with gemini-2.0-flash, claude-3-5-haiku)
- **複雑なタスク:** command + L (with deepseek-r1, o3-mini)
- **自走させたいタスク:** command + i Composer Agent YOLO (with claude-3-5-sonnet)

## まとめて実装が上手く行かない時の選択肢

LLMとツールの進化を信じてある程度のサイズ感の issue レベルのタスクをまるっと投げてみる。それも全然いいと思います。

ただ、その結果として「思うコードが上がってこなかった」となった場合に取れる選択肢として

1. プロンプトをしっかり書く
2. `.cursor/rules` で基本ルールを書いておく
3. 小さなユニットに分割してタスクを投げる

という選択肢があります。

### 1. プロンプトをしっかり書く

指示を明確に書くパターンです。
**正直「これ、自分で実装した方が早くね？」となる典型例なので、ここはあまり力を入れないようにしたいと思っています。**

ただ、この後の 「3. 小さなユニットに分割してタスクを投げる」 という選択肢を使う際にも有効なので、できるだけ楽をする方向性でこれに取り組むならどうするかを考えたいと思います。

↓↓↓ 楽をしよう ↓↓↓

1度のAIへの指示はこのくらい
```plaintext: プロンプト
@issues.md をやっている
spec のケースを洗出して
@spec-rules.md に従って
```

issueやEpicで複数のcommit, PRに分けると思うので、それらで横断して知っておくと良い情報や計画を作成しておく
- 毎回入力する必要がなくなる
- chatでも、agentでも、command + Kでも横断して情報を伝えられる
```md: .cursor/memories/issues.md
## やりたいこと
- {issue number}
- {具体的に達成したいこと}

## How
- {どうやって達成したいか}
- {どんな順番でやりたいか}
- {どこを修正したいか}

## What
- {達成した結果}
```

### 2. `.cursor/rules` で基本ルールを書いておく

先ほどのプロンプトで参照していた `@spec-rules.md に従って` もrulesです。
自動で読み取ってくれますが、明示的に指定するのも結構有効です。

特に設計思想や書き方系は、「違うな」と思うたびに微調整していくのをおすすめします。

- Backendのライブラリや設計思想
- Backendの specの書き方・実行の仕方
- Front-endのライブラリや設計思想
- Front-endの specの書き方・実行の仕方
- Linterの基本・実行の仕方
- Pull Requestの書き方
- Directory構成の説明（treeで用意しておく）
