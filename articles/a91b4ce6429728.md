---
title: "CursorでAIに小さなユニットでタスクを依頼する"
emoji: "🔖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## この記事はなに？

この記事では、現時点でのAIツールで確実に恩恵を受けるためには、**スコープを小さくすることで確実性を上げることが重要である**という考え方を紹介します。
ツールの機能説明やチャレンジングなハック的アプローチは扱わないものとします。

（AIに自由に編集・参照させている `memories.md` ファイルや、一連の大きなタスクの context を自然言語でまとめておく `issues.md` ファイルなどの取り組みは実験中なので除外する）

↓↓↓挑戦的でチャレンジングな記事はこちらへ↓↓↓
https://zenn.dev/globis/articles/cursor-project-rules


## 前提

- Cursor Composer Agent に **大きなタスクは渡さない**
- AIには、**小さなユニットに分けてタスクを実行してもらう**事で確実性を上げる

複雑性が小さいタスクや、既存コードが小さい場合には、Cursor Composer Agent に大きなタスクを渡してもらっても十分にWorkすると思います。
ただ、複雑性とコード量が増えてくると、小さい単位にタスクを切らないと、結局待ち時間が大きいのにあまり使えないコードが上がってきて終わった。みたいになることが多いと感じています。

その原因は、おそらく**人間が正しくAIに context を渡す事ができない**ため
人間の context を渡す能力とコストがボトルネックになってしまうなら、一旦スコープを小さくして context を正しく渡せるようにしてみようという発想です。

(Anthropic CEOの語る「事前学習 + 強化学習」のモデルの登場か、Cursor等のアプリケーション側で優秀な memories 機能が備われば話は違うのかもしれませんね)

### 実装のポイント

- **ユニットを小さく**
- **テストを先に書いて、成果物を明確に**

### モデルとインターフェースの選択

- **簡単なタスク:** command + K (with gemini-2.0-flash, claude-3-5-haiku)
- **複雑なタスク:** command + L (with deepseek-r1, o3-mini)
- **自走させたいタスク:** command + i Composer Agent YOLO (with claude-3-5-sonnet)

## 基本形

### テストケースを用意する

まずは達成したい物を明確にするためにテストケースを起こしましょう。

#### イメージ: 手順1 - やりたいことを雑に起こす
手書きで `.cursor/memories/issues.md` あたりにに起こす
chatやcomposerのスレッドが変わっても @issues.md で楽に context を渡すのが目的

**本来はもっと複雑なタスクをやるので、毎回長いプロンプトを書きたくない人は、ここでしっかり書いて引用しましょう**

```md: @issues.md
## やりたいこと

文字列を小文字にして前後の空白を削除する関数を作成

### テストケース example

- "Hello World" → "hello world"
- "  TEST  " → "test"
- 空文字列 → ""
- 数値123 → エラー？
```

#### イメージ: 手順2 - テストケースを起こす

- 部分的な変更は command + K (with gemini-2.0-flash, claude-3-5-haiku)
- 簡単な物は → command + L (with gemini-2.0-flash, claude-3-5-haiku) + Apply
- 複雑な物は → command + L (with o3-mini, deepseek-r1) + Apply

プロンプトイメージ
```plaintext
@issues.md をやる
@spec_file にテストケースに起こして
@vitest_spec_rules に従って
```

rulesに基本ルールは起こしておくと楽です。
ex: 日本語でcontextを書いて。スタック: vitest

とことん楽をしたい。
「AIのために時間なんて使ってられないぜ」（？）


```typescript
describe('normalizeString', () => {
  context('正常な文字列入力の場合', () => {
    it('大文字を小文字に変換し前後の空白を削除する', () => {
      expect(normalizeString('Hello World')).toBe('hello world');
      expect(normalizeString('  TEST  ')).toBe('test');
    });
  });

  context('空文字列の場合', () => {
    it('空文字列を返す', () => {
      expect(normalizeString('')).toBe('');
    });
  });

  context('非文字列入力の場合', () => {
    it('TypeErrorをスローする', () => {
      expect(() => normalizeString(123)).toThrow(TypeError);
      expect(() => normalizeString(null)).toThrow(TypeError);
    });
  });
});
```

### 「テストが通るまで実装して」

Composer Agent YOLOモードで、テストが通るまで実装してもらいます。
※ この程度の簡単な実装なら chat + apply で十分ですが、参考までに agent を使った例にします

雑に大枠は書き起こしておくと楽です。
ファイル作ってなんとなく作って Tab 押していればOK
```typescript: target_file.ts
const normalizeString = (text: string): string => {
    // TODO:
    return text
}
```

プロンプトイメージ
```plaintext
@issues.md を行う
@spec_file のテストに従って、@target_file を実装してください。
yarn vitest run --retry=0 {path} の実行を許可
テストが通るまで実行して
```



## ex: Rails などの実装のケース

### テストを書け

## 失敗談

- 大きなタスクを渡す（ex: 大きめのlibrary update）

## FEのマークアップ・デザインの実装


## ex: 純粋関数の実装

まず、一番優秀なのは純粋関数の実装だと思っています。
副作用がなく、外部の状態に依存せず、同じ入力に対して常に同じ出力を返すので、テストが用意で成果物が明確です。
